# This is a data file that contains information describing the text that is
# displayed on pages in the Lang section of Sonic Pi's help panel.

## Function name
## ====================
# A unique identifier for this function.
["sample"]

## Function summary
## ====================
# A short phrase describing this Sonic Pi function.
summary = "Trigger sample"

## Function description
## ====================
# The detailed description of this function.
doc = '''
Play back a recorded sound file (sample). Sonic Pi comes with lots of great samples included (see the section under help) but you can also load and play `.wav`, `.wave`, `.aif`, `.aiff`, `.ogg`, `.oga` or `.flac` files from anywhere on your computer too. To play a built-in sample use the corresponding keyword such as `sample :bd_haus`. To play any file on your computer use a full path such as `sample '/path/to/sample.wav'`.

There are many opts for manipulating the playback. For example, the `rate:` opt affects both the speed and the pitch of the playback. To control the rate of the sample in a pitch-meaningful way take a look at the `rpitch:` opt.

The sampler synth has three separate envelopes - one for amplitude, one for a low pass filter and another for a high pass filter. These work very similar to the standard synth envelopes except for two major differences. Firstly, the envelope times do not stretch or shrink to match the BPM. Secondly, the sustain time by default stretches to make the envelope fit the length of the sample. This is explained in detail in the tutorial.

Samples are loaded on-the-fly when first requested (and subsequently remembered). If the sample loading process takes longer than the schedule ahead time, the sample trigger will be skipped rather than be played late and out of time. To avoid this you may preload any samples you wish to work with using `load_sample` or `load_samples`.

It is possible to set the `start:` and `finish:` positions within the sample to play only a sub-section of it. These values can be automatically chosen based on an onset detection algorithm which will essentially isolate each individual drum or synth hit in the sample and let you access each one by an integer index (floats will be rounded to the nearest integer value). See the `onset:` docstring and examples for more information.

Finally, the sampler supports a powerful filtering system to make it easier to work with large folders of samples. The filter commands must be used before the first standard opt. There are six kinds of filter parameters you may use:

1. Folder strings - `'/foo/bar'` - which will add all samples within the folder to the set of candidates.
2. Recursive folder strings - `'/foo/bar/**'` - Folder strings ending with `**` will add all samples contained within all subfolders (searched recursively).
3. Sample strings - `'/path/to/sample.wav'` - which will add the specific sample to the set of candidates.
4. Other strings - `'foobar'` - which will filter the candidates based on whether the filename contains the string.
5. Regular expressions - `/b[aA]z.*/` - which will filter the candidates based on whether the regular expression matches the filename.
6. Keywords - `:quux` - will filter the candidates based on whether the keyword is a direct match of the filename (without extension).
7. Numbers - `0` - will select the candidate with that index (wrapping round like a ring if necessary).
8. Lists of the above - `['/foo/bar', 'baz', /0-9.*/]` - will recurse down and work through the internal filter parameters as if they were in the top level.
9. Lambdas - `lambda {|s| [s.choose] }` - the ultimate power tool for filters. Allows you to create a custom fn which receives a list of candidates as an arg and which should return a new list of candidates (this may be smaller, larger, re-ordered it's up to you).

By combining commands which add to the candidates and then filtering those candidates it is possible to work with folders full of samples in very powerful ways. Note that the specific ordering of filter parameters is irrelevant with the exception of the numbers - in which case the last number is the index. All the candidates will be gathered first before the filters are applied.

'''

## Function args
## ====================
# Args are the required parameters for the function. Each arg has two documented
# properties:
# - the arg's name
# - the arg's type (number, integer, symbol, ...).
# Example:
# (Repeat the following for every arg):
# [[chord.args]]
# name = "tonic"
# type = "symbol"

[["sample".args]]
name = "name_or_path"
type = "symbol_or_string"

## Function introduction
## ====================
# The label describing the version of Sonic Pi in which this function first appeared.
["sample".introduced]
label = "Introduced in v2.0"

## Function options
## ====================
# The options are the optional parameters of this function.
# Each option has two documented properties:
# - the option's name
# - the option's description doc.
# Example:
# [chord.options]
# label = "Options"

# Now repeat the following for every option:
# [[chord.options.list]]
# name = "invert:"
# doc = '''
# Apply the specified num inversions to chord. See the fn `chord_invert`.
# '''

["sample".options]
label = "Options"

[["sample".options.list]]
name = "rate:"
doc = '''
Rate with which to play back the sample. Higher rates mean an increase in pitch and a decrease in duration. Default is 1.
'''

[["sample".options.list]]
name = "beat_stretch:"
doc = '''
Stretch (or shrink) the sample to last for exactly the specified number of beats. Please note - this does *not* keep the pitch constant and is essentially the same as modifying the rate directly.
'''

[["sample".options.list]]
name = "pitch_stretch:"
doc = '''
Stretch (or shrink) the sample to last for exactly the specified number of beats. This attempts to keep the pitch constant using the `pitch:` opt. Note, it's very likely you'll need to experiment with the `window_size:`, `pitch_dis:` and `time_dis:` opts depending on the sample and the amount you'd like to stretch/shrink from original size.
'''

[["sample".options.list]]
name = "attack:"
doc = '''
Time to reach full volume. Default is 0.
'''

[["sample".options.list]]
name = "sustain:"
doc = '''
Time to stay at full volume. Default is to stretch to length of sample (minus attack and release times).
'''

[["sample".options.list]]
name = "release:"
doc = '''
Time (from the end of the sample) to go from full amplitude to 0. Default is 0.
'''

[["sample".options.list]]
name = "start:"
doc = '''
Position in sample as a fraction between 0 and 1 to start playback. Default is 0.
'''

[["sample".options.list]]
name = "finish:"
doc = '''
Position in sample as a fraction between 0 and 1 to end playback. Default is 1.
'''

[["sample".options.list]]
name = "pan:"
doc = '''
Stereo position of audio. -1 is left ear only, 1 is right ear only, and values in between position the sound accordingly. Default is 0.
'''

[["sample".options.list]]
name = "amp:"
doc = '''
Amplitude of playback.
'''

[["sample".options.list]]
name = "pre_amp:"
doc = '''
Amplitude multiplier which takes place immediately before any internal FX such as the low pass filter, compressor or pitch modification. Use this opt if you want to overload the compressor.
'''

[["sample".options.list]]
name = "onset:"
doc = '''
Analyse the sample with an onset detection algorithm and automatically set or override the `start:` and `finish:` opts to play the nth onset only. Allows you to treat a rhythm sample as a palette of individual drum/synth hits. If `start:` or `finish:` opts are used in addition to `onset:` then they will work within the onset rather than the whole sample. Floats are rounded to the nearest whole number.
'''

[["sample".options.list]]
name = "on:"
doc = '''
If specified and false/nil/0 will stop the sample from being played. Ensures all opts are evaluated.
'''

[["sample".options.list]]
name = "slice:"
doc = '''
Divides the sample duration evenly into `num_slices:` sections (defaults to 16) and set the `start:` and `finish:` opts to play the nth slice only. If `start:` or `finish:` opts are used in addition to `slice:` then they will work within the slice rather than the whole sample. Use the envelope opts to remove any clicks introduced if the slice boundary is in the middle of a sound. Also consider `onset:` as an alternative to `slice:`. If `onset:` is also used then the slices will be within the onset rather than the whole sample. Floats are rounded to the nearest whole number.
'''

[["sample".options.list]]
name = "num_slices:"
doc = '''
Number of slices to divide the sample into when using the `slice:` opt. Defaults to 16. Floats are rounded to the nearest whole number.
'''

[["sample".options.list]]
name = "norm:"
doc = '''
Normalise the audio (make quieter parts of the sample louder and louder parts quieter) - this is similar to the normaliser FX. This may emphasise any clicks caused by clipping.
'''

[["sample".options.list]]
name = "lpf:"
doc = '''
Cutoff value of the built-in low pass filter (lpf) in MIDI notes. Unless specified, the lpf is *not* added to the signal chain.
'''

[["sample".options.list]]
name = "lpf_init_level:"
doc = '''
The initial low pass filter envelope value as a MIDI note. This envelope is bypassed if no lpf env opts are specified. Default value is to match the `lpf_min:` opt.
'''

[["sample".options.list]]
name = "lpf_attack_level:"
doc = '''
The peak lpf cutoff (value of cutoff at peak of attack) as a MIDI note. Default value is to match the `lpf_decay_level:` opt.
'''

[["sample".options.list]]
name = "lpf_decay_level:"
doc = '''
The level of lpf cutoff after the decay phase as a MIDI note. Default value is to match the `lpf_sustain_level:` opt.
'''

[["sample".options.list]]
name = "lpf_sustain_level:"
doc = '''
The sustain cutoff (value of lpf cutoff at sustain time) as a MIDI note. Default value is to match the `lpf_release_level:` opt.
'''

[["sample".options.list]]
name = "lpf_release_level:"
doc = '''
The final value of the low pass filter envelope as a MIDI note. This envelope is bypassed if no lpf env opts are specified. Default value is to match the `lpf:` opt.
'''

[["sample".options.list]]
name = "lpf_attack:"
doc = '''
Attack time for lpf cutoff filter. Amount of time (in beats) for sound to reach full cutoff value. Default value is set to match amp envelope's attack value.
'''

[["sample".options.list]]
name = "lpf_decay:"
doc = '''
Decay time for lpf cutoff filter. Amount of time (in beats) for sound to move from full cutoff value (cutoff attack level) to the cutoff sustain level. Default value is set to match amp envelope's decay value.
'''

[["sample".options.list]]
name = "lpf_sustain:"
doc = '''
Amount of time for lpf cutoff value to remain at sustain level in beats. When -1 (the default) will auto-stretch.
'''

[["sample".options.list]]
name = "lpf_release:"
doc = '''
Amount of time (in beats) for sound to move from lpf cutoff sustain value to lpf cutoff min value. Default value is set to match amp envelope's release value.
'''

[["sample".options.list]]
name = "lpf_min:"
doc = '''
Starting value of the lpf cutoff envelope. Default is 30.
'''

[["sample".options.list]]
name = "lpf_env_curve:"
doc = '''
Select the shape of the curve between levels in the lpf cutoff envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed.
'''

[["sample".options.list]]
name = "hpf:"
doc = '''
Cutoff value of the built-in high pass filter (hpf) in MIDI notes. Unless specified, the hpf is *not* added to the signal chain.
'''

[["sample".options.list]]
name = "hpf_init_level:"
doc = '''
The initial high pass filter envelope value as a MIDI note. This envelope is bypassed if no hpf env opts are specified. Default value is set to 130.
'''

[["sample".options.list]]
name = "hpf_attack_level:"
doc = '''
The peak hpf cutoff (value of cutoff at peak of attack) as a MIDI note. Default value is to match the `hpf_decay_level:` opt.
'''

[["sample".options.list]]
name = "hpf_decay_level:"
doc = '''
The level of hpf cutoff after the decay phase as a MIDI note. Default value is to match the `hpf_sustain_level:` opt.
'''

[["sample".options.list]]
name = "hpf_sustain_level:"
doc = '''
The sustain cutoff (value of hpf cutoff at sustain time) as a MIDI note. Default value is to match the `hpf_release_level:` opt.
'''

[["sample".options.list]]
name = "hpf_release_level:"
doc = '''
The sustain hpf cutoff (value of hpf cutoff at sustain time) as a MIDI note. Default value is to match the `hpf:` opt.
'''

[["sample".options.list]]
name = "hpf_attack:"
doc = '''
Attack time for hpf cutoff filter. Amount of time (in beats) for sound to reach full cutoff value. Default value is set to match amp envelope's attack value.
'''

[["sample".options.list]]
name = "hpf_decay:"
doc = '''
Decay time for hpf cutoff filter. Amount of time (in beats) for sound to move from full cutoff value (cutoff attack level) to the cutoff sustain level. Default value is set to match amp envelope's decay value.
'''

[["sample".options.list]]
name = "hpf_sustain:"
doc = '''
Amount of time for hpf cutoff value to remain at sustain level in beats. When -1 (the default) will auto-stretch.
'''

[["sample".options.list]]
name = "hpf_release:"
doc = '''
Amount of time (in beats) for sound to move from hpf cutoff sustain value to hpf cutoff min value. Default value is set to match amp envelope's release value.
'''

[["sample".options.list]]
name = "hpf_env_curve:"
doc = '''
Select the shape of the curve between levels in the hpf cutoff envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed.
'''

[["sample".options.list]]
name = "hpf_max:"
doc = '''
Maximum value of the high pass filter envelope. Default is 200.
'''

[["sample".options.list]]
name = "rpitch:"
doc = '''
Rate modified pitch. Multiplies the rate by the appropriate ratio to shift up or down the specified amount in MIDI notes. Please note - this does *not* keep the duration and rhythmical rate constant and is essentially the same as modifying the rate directly.
'''

[["sample".options.list]]
name = "pitch:"
doc = '''
Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc. Maximum upper limit of 24 (up 2 octaves). Lower limit of -72 (down 6 octaves). Decimal numbers can be used for fine tuning.
'''

[["sample".options.list]]
name = "window_size:"
doc = '''
Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Pitch shift works by chopping the input into tiny slices, then playing these slices at a higher or lower rate. If we make the slices small enough and overlap them, it sounds like the original sound with the pitch changed. The window_size is the length of the slices and is measured in seconds. It needs to be around 0.2 (200ms) or greater for pitched sounds like guitar or bass, and needs to be around 0.02 (20ms) or lower for percussive sounds like drum loops. You can experiment with this to get the best sound for your input.
'''

[["sample".options.list]]
name = "pitch_dis:"
doc = '''
Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Pitch dispersion - how much random variation in pitch to add. Using a low value like 0.001 can help to 'soften up' the metallic sounds, especially on drum loops. To be really technical, pitch_dispersion is the maximum random deviation of the pitch from the pitch ratio (which is set by the `pitch:` opt).
'''

[["sample".options.list]]
name = "time_dis:"
doc = '''
Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Time dispersion - how much random delay before playing each grain (measured in seconds). Again, low values here like 0.001 can help to soften up metallic sounds introduced by the effect. Large values are also fun as they can make soundscapes and textures from the input, although you will most likely lose the rhythm of the original. NB - This won't have an effect if it's larger than window_size.
'''

[["sample".options.list]]
name = "compress:"
doc = '''
Enable the compressor. This sits at the end of the internal FX chain immediately before the `amp:` opt. Therefore to drive the compressor use the `pre_amp:` opt which will amplify the signal before it hits any internal FX. The compressor compresses the dynamic range of the incoming signal. Equivalent to automatically turning the amp down when the signal gets too loud and then back up again when it's quiet. Useful for ensuring the containing signal doesn't overwhelm other aspects of the sound. Also a general purpose hard-knee dynamic range processor which can be tuned via the opts to both expand and compress the signal.
'''

[["sample".options.list]]
name = "threshold:"
doc = '''
Threshold value determining the break point between slope_below and slope_above. Only valid if the compressor is enabled by turning on the `compress:` opt.
'''

[["sample".options.list]]
name = "slope_below:"
doc = '''
Slope of the amplitude curve below the threshold. A value of 1 means that the output of signals with amplitude below the threshold will be unaffected. Greater values will magnify and smaller values will attenuate the signal. Only valid if the compressor is enabled by turning on the `compress:` opt.
'''

[["sample".options.list]]
name = "slope_above:"
doc = '''
Slope of the amplitude curve above the threshold. A value of 1 means that the output of signals with amplitude above the threshold will be unaffected. Greater values will magnify and smaller values will attenuate the signal. Only valid if the compressor is enabled by turning on the `compress:` opt.
'''

[["sample".options.list]]
name = "clamp_time:"
doc = '''
Time taken for the amplitude adjustments to kick in fully (in seconds). This is usually pretty small (not much more than 10 milliseconds). Also known as the time of the attack phase. Only valid if the compressor is enabled by turning on the `compress:` opt.
'''

[["sample".options.list]]
name = "relax_time:"
doc = '''
Time taken for the amplitude adjustments to be released. Usually a little longer than clamp_time. If both times are too short, you can get some (possibly unwanted) artefacts. Also known as the time of the release phase. Only valid if the compressor is enabled by turning on the `compress:` opt.
'''

[["sample".options.list]]
name = "slide:"
doc = '''
Default slide time in beats for all slide opts. Individually specified slide opts will override this value.
'''

[["sample".options.list]]
name = "path:"
doc = '''
Path of the sample to play. Typically this opt is rarely used instead of the more powerful source/filter system. However it can be useful when working with pre-made opt maps.
'''

## Function examples
## ====================
# Each function may have one or more examples. If it has any, they are listed
# under an overall 'Example' or 'Examples' label (heading), and each example has
# a numbered sub-heading.
# Example:
# [chord.examples]
# label = "Example"
# label_plural = "Examples"

# Now repeat the following for every example:
# [[chord.examples.list]]
# label = "Example 1"
# example = '''
# puts (chord :e, :minor) # returns a ring of midi notes - (ring 64, 67, 71)
# '''
["sample".examples]
label = "Example"
label_plural = "Examples"

[["sample".examples.list]]
label = "Example 1"
example = '''

# Play a built-in sample
sample :loop_amen # Plays the Amen break
'''

[["sample".examples.list]]
label = "Example 2"
example = '''

# Play two samples at the same time
# with incredible timing accuracy
sample :loop_amen
sample :ambi_lunar_land # Note, for timing guarantees select the pref:
                        #   Studio -> Synths and FX -> Enforce timing guarantees
'''

[["sample".examples.list]]
label = "Example 3"
example = '''

# Create a simple repeating bass drum
live_loop :bass do
  sample :bd_haus
  sleep 0.5
end
'''

[["sample".examples.list]]
label = "Example 4"
example = '''

# Create a more complex rhythm with multiple live loops:
live_loop :rhythm do
  sample :tabla_ghe3 if (spread 5, 7).tick
  sleep 0.125
end
live_loop :bd, sync: :rhythm do
  sample :bd_haus, lpf: 90, amp: 2
  sleep 0.5
end
'''

[["sample".examples.list]]
label = "Example 5"
example = '''

# Change the playback speed of the sample using rate:
sample :loop_amen, rate: 0.5 # Play the Amen break at half speed
                             # for old school hip-hop
'''

[["sample".examples.list]]
label = "Example 6"
example = '''

# Speed things up
sample :loop_amen, rate: 1.5 # Play the Amen break at 1.5x speed
                             # for a jungle/gabba sound
'''

[["sample".examples.list]]
label = "Example 7"
example = '''

# Go backwards
sample :loop_amen, rate: -1 # Negative rates play the sample backwards
'''

[["sample".examples.list]]
label = "Example 8"
example = '''

# Fast rewind
sample :loop_amen, rate: -3 # Play backwards at 3x speed for a fast rewind effect
'''

[["sample".examples.list]]
label = "Example 9"
example = '''

# Start mid sample
sample :loop_amen, start: 0.5 # Start playback half way through
'''

[["sample".examples.list]]
label = "Example 10"
example = '''

# Finish mid sample
sample :loop_amen, finish: 0.5 # Finish playback half way through
'''

[["sample".examples.list]]
label = "Example 11"
example = '''

# Play part of a sample
sample :loop_amen, start: 0.125, finish: 0.25 # Play the second eighth of the sample
'''

[["sample".examples.list]]
label = "Example 12"
example = '''

# Finishing before the start plays backwards
sample :loop_amen, start: 0.25, finish: 0.125 # Play the second eighth of the sample backwards
'''

[["sample".examples.list]]
label = "Example 13"
example = '''

# Play a section of a sample at quarter speed backwards
sample :loop_amen, start: 0.125, finish: 0.25, rate: -0.25 # Play the second eighth of the
                                                           # amen break backwards at a
                                                           # quarter speed
'''

[["sample".examples.list]]
label = "Example 14"
example = '''

# Control a sample synchronously
s = sample :loop_amen, lpf: 70
sleep 0.5
control s, lpf: 130
sleep 0.5
synth :dsaw, note: :e3 # This is triggered 1s from start
'''

[["sample".examples.list]]
label = "Example 15"
example = '''
 # Controlling a sample asynchronously
sample :loop_amen, lpf: 70 do |s|
  sleep 1                                # This block is run in an implicit in_thread
  control s, lpf: 130                    # and therefore is asynchronous
end
sleep 0.5
synth :dsaw, note: :e3 # This is triggered 0.5s from start
'''

[["sample".examples.list]]
label = "Example 16"
example = '''

# Play with slices
sample :loop_garzul, slice: 0      # => play the first 16th of the sample
sleep 0.5
4.times do
  sample :loop_garzul, slice: 1    # => play the second 16th of the sample 4 times
  sleep 0.125
end
sample :loop_garzul, slice: 4, num_slices: 4, rate: -1      # => play the final quarter backwards

'''

[["sample".examples.list]]
label = "Example 17"
example = '''

# Build a simple beat slicer
use_sample_bpm :loop_amen                    # Set the BPM to match the amen break sample
live_loop :beat_slicer do
  n = 8                                      # Specify number of slices
                                             # (try changing to 2, 4, 6, 16 or 32)
  s = rand_i n                               # Choose a random slice within range
  sample :loop_amen, slice: s, num_slices: n # Play the specific part of the sample
  sleep 1.0/n                                # Sleep for the duration of the slice
end
'''

[["sample".examples.list]]
label = "Example 18"
example = '''

# Play with the built-in low pass filter, high pass filter and compressor
sample :loop_amen, lpf: 80, hpf: 70, compress: 1, pre_amp: 10 # Make the amen break sound punchy.
'''

[["sample".examples.list]]
label = "Example 19"
example = '''

# Use the cutoff filter envelopes
sample :loop_garzul, lpf_attack: 8 # Sweep the low pass filter up over 8 beats
sleep 8
sample :loop_garzul, hpf_attack: 8 # Sweep the high pass filter down over 8 beats
'''

[["sample".examples.list]]
label = "Example 20"
example = '''

# Sample stretching
puts sample_duration :loop_industrial                   # => 0.88347
puts sample_duration :loop_industrial, beat_stretch: 1  # => 1
live_loop :industrial do
  sample :loop_industrial, beat_stretch: 1              # Stretch the sample to make it 1 beat long
  sleep 1                                               # This now loops perfectly.
                                                        # However, note that stretching/shrinking
                                                        # also modifies the pitch.
end
'''

[["sample".examples.list]]
label = "Example 21"
example = '''

# Sample shrinking
puts sample_duration :loop_garzul                       # => 8
puts sample_duration :loop_garzul, beat_stretch: 6      # => 6
live_loop :garzul do
  sample :loop_garzul, beat_stretch: 6                  # As :loop_garzul is longer than 6 beats
                                                        # it is shrunk to fit. This increases the
                                                        # pitch.
  sleep 6
end
'''

[["sample".examples.list]]
label = "Example 22"
example = '''

# Sample stretching matches the BPM
use_bpm 30                                              # Set the BPM to 30
puts sample_duration :loop_garzul                       # => 4.0 (at 30 BPM the sample lasts for 4 beats)
puts sample_duration :loop_garzul, beat_stretch: 6      # => 6.0
live_loop :garzul do
  sample :loop_garzul, beat_stretch: 6                  # The sample is stretched to match 6 beats at 30 BPM
  sleep 6
end
'''

[["sample".examples.list]]
label = "Example 23"
example = '''

# External samples
sample "/path/to/sample.wav"                          # Play any Wav, Aif, Ogg, Oga, or FLAC sample on your computer
                                                        # by simply passing a string representing the full
                                                        # path
'''

[["sample".examples.list]]
label = "Example 24"
example = '''

# Sample pack filtering
dir = "/path/to/dir/of/samples"                       # You can easily work with a directory of samples
sample dir                                              # Play the first sample in the directory
                                                        # (it is sorted alphabetically)
sample dir, 1                                           # Play the second sample in the directory
sample dir, 99                                          # Play the 100th sample in the directory, or if there
                                                        # are fewer, treat the directory like a ring and keep
                                                        # wrapping the index round until a sample is found.
                                                        # For example, if there are 90 samples, the 10th sample
                                                        # is played (index 9).
sample dir, "120"                                     # Play the first sample in the directory that contains
                                                        # the substring "120".
                                                        # For example, this may be "beat1_120_rave.wav"
sample dir, "120", 1                                  # Play the second sample in the directory that contains
                                                        # the substring "120".
                                                        # For example, this may be "beat2_120_rave.wav"
sample dir, /beat[0-9]/                                 # Play the first sample in the directory that matches
                                                        # the regular expression /beat[0-9]/.
                                                        # For example, this may be "beat0_100_trance.wav"
                                                        # You may use the full power of Ruby's regular expression
                                                        # system here: http://ruby-doc.org/core-2.1.1/Regexp.html
sample dir, /beat[0-9]0/, "100"                       # Play the first sample in the directory that both matches
                                                        # the regular expression /beat[0-9]0/ and contains the
                                                        # the substring "100".
                                                        # For example, this may be "beat10_100_rave.wav"
'''

[["sample".examples.list]]
label = "Example 25"
example = '''

# Filtering built-in samples
                                                        # If you don't pass a directory source, you can filter over
                                                        # the built-in samples.
sample "tabla_"                                       # Play the first built-in sample that contains the substring
                                                        # "tabla"
sample "tabla_", 2                                    # Play the third built-in sample that contains the substring
                                                        # "tabla"
'''

[["sample".examples.list]]
label = "Example 26"
example = '''

# Play with whole directories of samples
load_samples "tabla_"                                 # You may pass any of the source/filter options to load_samples
                                                        # to load all matching samples. This will load all the built-in
                                                        # samples containing the substring "tabla_"
live_loop :tabla do
  sample "tabla_", tick                               # Treat the matching samples as a ring and tick through them
  sleep 0.125
end
'''

[["sample".examples.list]]
label = "Example 27"
example = '''

# Specify multiple sources
dir1 = "/path/to/sample/directory"
dir2 = "/path/to/other/sample/directory"
sample dir1, dir2, "foo"                              # Match the first sample that contains the string "foo" out of
                                                        # all the samples in dir1 and dir2 combined.
                                                        # Note that the sources must be listed before any filters.
'''

[["sample".examples.list]]
label = "Example 28"
example = '''

# List contents recursively
dir = "/path/to/sample/directory"                     # By default the list of all top-level samples within the directory
                                                        # is considered.
dir_recursive = "/path/to/sample/directory/**"        # However, if you finish your directory string with ** then if that
                                                        # directory contains other directories then the samples within the
                                                        # subdirectories and their subsubdirectories in turn are considered.
sample dir, 0                                           # Play the first top-level sample in the directory
sample dir_recursive, 0                                 # Play the first sample found after combining all samples found in
                                                        # the directory and all directories within it recursively.
                                                        # Note that if there are many sub directories this may take some time
                                                        # to execute. However, the result is cached so subsequent calls will
                                                        # be fast.
'''

[["sample".examples.list]]
label = "Example 29"
example = '''

# Bespoke filters
filter = lambda do |candidates|                         # If the built-in String, Regexp and index filters are not sufficient
  [candidates.choose]                                   # you may write your own. They need to be a function which takes a list
end                                                     # of paths to samples and return a list of samples. This one returns a
                                                        # list of a single randomly selected sample.
8.times do
  sample "drum_", filter                              # Play 8 randomly selected samples from the built-in sample set that also
  sleep 0.25                                            # contain the substring "drum_"
end
'''

[["sample".examples.list]]
label = "Example 30"
example = '''

# Basic Onset Detection

sample :loop_tabla, start: 0, finish: 0.00763           # If you know the right start: and finish: values, you can extract a
                                                        # single drum hit from a longer sample. However, finding these values
                                                        # can be very time consuming.
sleep 1
                                                        # Instead of specifying the start: and finish: values manually you can
                                                        # use the onset: option to find them for you using an integer index.
sample :loop_tabla, onset: 0                            # onset: 0 will set the start: and finish: values so that the first
                                                        # percussive sound (something that shifts from quiet to loud quickly)
                                                        # is picked out.
sleep 1

sample :loop_tabla, onset: 1                            # We can easily find the second percussive sound in the sample with
                                                        # onset: 1
'''

[["sample".examples.list]]
label = "Example 31"
example = '''


# Ticking through onsets

                                                        # The onsets are actually a ring so the index will wrap around. This
                                                        # means that if there are only 8 onsets in a sample, specifying an
                                                        # onset of 100 will still return one of the 8 onsets. This means we
                                                        # can use tick to work through each onset in sequence. This allows us
                                                        # to redefine the rhythm and tempo of a sample


live_loop :tabla do
  use_bpm 50                                            # We can choose our own BPM here - it doesn't need to match the sample
  sample :loop_tabla, onset: tick                       # tick through each onset in sequence
  sleep [0.125, 0.25].choose                            # randomly choose a delay between onset triggers
end

'''

[["sample".examples.list]]
label = "Example 32"
example = '''

# Random Onset Triggering
                                                        # We can easily pick a random onset using the pick fn
use_bpm 50
live_loop :tabla do
  sample :loop_tabla, onset: pick                       # Each time round the live loop we now trigger a random onset
  sleep [0.125, 0.25].choose                            # creating an infinite stream of randomly selected drums
end


        
'''

[["sample".examples.list]]
label = "Example 33"
example = '''

# Repeatable Random Onsets
                                                        # Instead of an infinite stream of choices, we can combine iteration
                                                        # and use_random_seed to create repeatable riffs:
live_loop :tabla do
  use_random_seed 30000                                 # every 8 times, reset the random seed, this resets the riff
  8.times do
    sample :loop_tabla, onset: pick
    sleep [0.125, 0.25].choose
  end
end


'''

[["sample".examples.list]]
label = "Example 34"
example = '''

#  Random Onset Duration
                                                            # Each onset has a variable length (determined by the sample contents).
                                                            # Therefore, if you wish to ensure each onset has a specific length it
                                                            # is necessary to use the sample's amplitude envelope.
                                                            # As the sample's envelope automatically changes the sustain: value to
                                                            # match the duration - you also need to override this with a value of 0.
live_loop :tabla do
  sample :loop_tabla, onset: pick, sustain: 0, release: 0.1 # Each drum onset will now be no longer than 0.1. Note that the envelope
                                                            # for a sample only determines the maximum duration of a sample trigger.
                                                            # If the actual audible duration of the onset is smaller than 0.1 then
                                                            # it will *not* be extended.
  sleep [0.125, 0.25].choose
end


'''

[["sample".examples.list]]
label = "Example 35"
example = '''

# Onset lambdas

                                                        # The onset index can be a lambda as well as an integer. If a lambda is
                                                        # given, it will be passed a ring of all of the onsets as an argument.
                                                        # This will be a ring of maps:

l = lambda {|c| puts c ; c[0]}                          # define a lambda which accepts a single argument, prints it and
                                                        # returns the first value. This particular example is essentially
                                                        # the same as using onset: 0 with the side effect of also printing out
                                                        # the full ring of onsets:

sample :loop_tabla, onset: l                            # (ring {:start=>0.0, :finish=>0.0076}, {:start=>0.0076, :finish 0.015}...)

                                                        # We are therefore free to define this lambda to do anything we want.
                                                        # This gives us very powerful control over the choice of onset. It is
                                                        # unlikely you will use this frequently, but it is a powerful tool
                                                        # that's there when you need it.


'''

[["sample".examples.list]]
label = "Example 36"
example = '''

sample :loop_tabla, onset: 1                                         # Plays the 2nd onset (the first onset would have index 0)

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0304}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)


'''

[["sample".examples.list]]
label = "Example 37"
example = '''

sample :loop_tabla, onset: 1, slice: 0, num_slices: 1                # Plays the 2nd onset. This behaves the same as not specifying
                                                                     # a slice as we select the first of one slices.

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0304}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)


'''

[["sample".examples.list]]
label = "Example 38"
example = '''

sample :loop_tabla, onset: 1, slice: 0, num_slices: 2                # This plays the first half of the 2nd onset.
                                                                     # This is because  we split that onset into two slices and
                                                                     # play just the first slice (with index 0).

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0227}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)

'''

[["sample".examples.list]]
label = "Example 39"
example = '''

sample :loop_tabla, onset: 1, slice: 0, num_slices: 4                # This plays the first quarter of the 2nd onset.
                                                                     # This is because we split that onset into four slices and
                                                                     # play just the first slice (with index 0).

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0189}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)

sample :loop_tabla, onset: 1, slice: 0, num_slices: 4, finish: 0.5   # Will play the first 1/8th of the 2nd onset.
                                                                     # This is because we split that specific onset into 4 slices
                                                                     # and then only play the first half of the first slice.

                                                                     # Will override opts with: {start: 0.0151, finish: 0.017}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)

sample :loop_tabla, onset: 1, slice: 0, num_slices: 4, finish: 0.0, start: 0.5   # Will play the first 1/8th of the 2nd onset backwards..
                                                                                 # This is because we split that specific onset into 4 slices
                                                                                 # and then only play from the first half of the first slice
                                                                                 # back to the beginning.

                                                                                 # Will override opts with: {start: 0.017, finish: 0.0151}
                                                                                 # (these values are specific to the :loop_tabla sample and
                                                                                 # will vary for different samples)

'''

